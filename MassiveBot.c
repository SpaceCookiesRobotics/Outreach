#pragma config(Sensor, in1,    blahY,          sensorAnalog)
#pragma config(Sensor, in2,    blahX,          sensorAnalog)
#pragma config(Sensor, dgtl1,  RPM,            sensorRotation)
#pragma config(Sensor, dgtl2,  BumpA,          sensorTouch)
#pragma config(Sensor, dgtl3,  BumpB,          sensorTouch)
#pragma config(Motor,  port2,           FrontRight,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           FrontLeft,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           MotorTester,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           BackRight,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           BackLeft,      tmotorVex393_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "../Shared/Accelerometer.h"

bool Roughly(int measurement, int value, float tolerance) {
	return abs(value - measurement) < tolerance * value;
}

#define TOLERANCE 0.1

task main() {
	int max = 0;
	while(true) {
		// Left:  V:Ch3 H:Ch4
		// Right: V:Ch2 H:Ch1
		int arcade_fwrd = vexRT[Ch2];
		int arcade_turn = vexRT[Ch1];
		int crab_side = vexRT[Ch4];
		int crab_fwrd = vexRT[Ch3];

		motor[FrontRight] = 1.0 * (arcade_fwrd + crab_fwrd - arcade_turn + crab_side);
		motor[BackRight]  = 1.0 * (arcade_fwrd + crab_fwrd - arcade_turn - crab_side);
		motor[FrontLeft]  = 1.0 * (arcade_fwrd + crab_fwrd + arcade_turn - crab_side);
		motor[BackLeft]   = 1.0 * (arcade_fwrd + crab_fwrd + arcade_turn + crab_side);

		int shock =
		abs(AnalogToMilliGees(SensorValue[blahX])) +
		abs(AnalogToMilliGees(SensorValue[blahY]));
		if (shock > max) {
			clearLCDLine(0); displayLCDNumber(0, 1, shock);
			max = shock;
		}
		bool cheater = vexRT[Btn5U] && vexRT[Btn6D];

		clearLCDLine(1); displayLCDCenteredString(1, cheater ? "Boss" : "Careful");

		// Driver goes to the Penalty box if the accelerometer triggers
		if (shock > 400 && !cheater) {
			clearLCDLine(1); displayLCDCenteredString(1, "Penalty");
			playSound(soundDownwardTones);
			motor[FrontLeft] = 0;
			motor[FrontRight] = 0;
			motor[BackLeft] = 0;
			motor[BackRight] = 0;
			sleep(10000);  // 10s
			clearLCDLine(1);
		}
		if (nLCDButtons & 4) {
			// Enter the Motor tester code if the right button of the display is pressed
			// At startup, try to spin the MotorTester motor. If we get a read-out, stay in
			// calibration mode.
			motor[MotorTester] = 127;
			int previous = SensorValue[RPM];
			int rpm = 0;
			int startTime = time1[T1];
			while (nLCDButtons & 4) {
				wait1Msec(100);
				int current = SensorValue[RPM];
				int increment = abs(previous - current);
				previous = current;
				// The shaft encoder has 180 increments per revolution, and we have 600 measurements
				// per minute.
				rpm = 0.9 * (increment * 600 / 180);
				clearLCDLine(0);
				displayLCDString(0, 0, "RPM");
				displayLCDNumber(0, 5, rpm);
				clearLCDLine(1);
				if (Roughly(rpm, 240, TOLERANCE)) {
					displayLCDString(1, 1, "Turbo");
					} else if (Roughly(rpm, 160, TOLERANCE)) {
					displayLCDString(1, 1, "High-speed");
					} else if (Roughly(rpm, 100, TOLERANCE)) {
					displayLCDString(1, 1, "Normal");
					} else {
					displayLCDString(1, 1, "Unknown");
				}
				// If it's not spinning, no motor is connected to the tester.
				if (time1[T1] > startTime + 1000 && rpm == 0) {
					break;
				}
			}
			motor[MotorTester] = 0;
			clearLCDLine(0);
			clearLCDLine(1);
		}
	}
}
