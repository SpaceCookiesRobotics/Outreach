#pragma config(Sensor, in1,    blahY,          sensorAnalog)
#pragma config(Sensor, in2,    blahX,          sensorAnalog)
#pragma config(Sensor, dgtl2,  BumpA,          sensorTouch)
#pragma config(Sensor, dgtl3,  BumpB,          sensorTouch)
#pragma config(Motor,  port2,           FrontRight,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           FrontLeft,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           BackRight,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           BackLeft,      tmotorVex393_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int toMilliGees(int analog) {
	// Accelerometer v1.0
	// https://www.vexrobotics.com/276-2332.html
  // With no jumper: 1.6v to 3.4v from -2g to +2g
  // Analog to digital converter: 0 to 4095
  //   1000 * ((5.0 * analog / 4096) - 2.5)
  return 5000 * analog / 4096 - 2500;
}

task main() {
	int max = 0;
	while(true) {
		// Left:  V:Ch3 H:Ch4
	  // Right: V:Ch2 H:Ch1
	  int arcade_fwrd = vexRT[Ch2];
	  int arcade_turn = vexRT[Ch1];
	  int crab_side = vexRT[Ch4];
    int crab_fwrd = vexRT[Ch3];

	  motor[FrontRight] = 1.0 * (arcade_fwrd + crab_fwrd - arcade_turn + crab_side);
		motor[BackRight]  = 1.0 * (arcade_fwrd + crab_fwrd - arcade_turn - crab_side);
		motor[FrontLeft]  = 1.0 * (arcade_fwrd + crab_fwrd + arcade_turn - crab_side);
		motor[BackLeft]   = 1.0 * (arcade_fwrd + crab_fwrd + arcade_turn + crab_side);

		int shock = abs(toMilliGees(SensorValue[blahX])) + abs(toMilliGees(SensorValue[blahY]));
		if (shock > max) {
		clearLCDLine(0); displayLCDNumber(0, 1, shock);
    max = shock;
  }
		bool cheater = vexRT[Btn5U] && vexRT[Btn6D];

		clearLCDLine(1); displayLCDCenteredString(1, cheater ? "Boss" : "Careful");

		// Driver goes to the Penalty box if the accelerometer triggers
		if (shock > 300 && !cheater) {
			clearLCDLine(1); displayLCDCenteredString(1, "Penalty");
			playSound(soundDownwardTones);
			motor[FrontLeft] = 0;
			motor[FrontRight] = 0;
			motor[BackLeft] = 0;
			motor[BackRight] = 0;
			sleep(10000);  // 10s
			clearLCDLine(1);
		}
	}
}
